using namespace vex;

//Creates a competition object that allows access to Competition methods.
vex::competition    Competition;

// Constants
const int COLOR = 1; // -1 for red, 1 for blue
const int START_POS = 0; //0 for the closer one, 1 for the further one

// Function declarations
void liftOneLevelUp();
void liftOneLevelDown();
void setClawControls();
void tankMoveRightMotors();
void tankMoveLeftMotors();
void tankMoveRightMotorsByRevs(double revs, double speed);
void tankMoveLeftMotorsByRevs(double revs, double speed);
void driveControl();
void stopLift();
void ballControl();
void loadBall();
void unloadBall();
void ballShooterStop();
void shootBall();
void ballLoaderStop();
void clawStop();
void debug(); // Debug function?
void moveBaseByRevs(double revs, double speed);
void setCapFlipperControls();
void capFlipperToggleFwd();
void capFlipperToggleRev();
void clawDown();

void clawUp();
// Global vars
char clawCondition = 'd'; // 'd' for 'down', 'u' for 'up'

// Motors object declaration
controller firstController = controller(controllerType::primary);
motor clawMotor = motor(7, gearSetting::ratio18_1, false);
motor baseMotorLeftFront = motor(10, gearSetting::ratio18_1, false);
motor baseMotorRightFront = motor(6, gearSetting::ratio18_1, false);
motor baseMotorLeftBack = motor(9, gearSetting::ratio18_1, false);
motor baseMotorRightBack = motor(8, gearSetting::ratio18_1, false);
motor torqueLiftLeft = motor(3, gearSetting::ratio36_1, false);
motor torqueLiftRight = motor(1, gearSetting::ratio36_1, false);
motor ballLoader = motor(4, gearSetting::ratio18_1, false);
motor ballShooter = motor(2, gearSetting::ratio18_1, false);
motor capFlipper = motor(5, gearSetting::ratio18_1, false);


/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */ 
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton( void ) {
    //---------------------------------------------------------------------------
    //                                 SET STOPPINGS                                
    //  Set claw and lift motors to Hold stopping                                
    //---------------------------------------------------------------------------

    torqueLiftLeft.setStopping(brakeType::hold);
    torqueLiftRight.setStopping(brakeType::hold);
    clawMotor.setStopping(brakeType::hold);
    ballShooter.setStopping(brakeType::coast);
    //---------------------------------------------------------------------------
    //                          CALIBRATE LIFT AND CLAW                               
    //  Bring motors lift to lowest possible pos, check for v=0,                 
    //  and then set absolute value of rotation to 0                                 
    //---------------------------------------------------------------------------
    //torqueLiftLeft.spin(directionType::rev);
    //torqueLiftRight.spin(directionType::rev);
    //while (torqueLiftLeft.velocity(velocityUnits::pct) > 0 || torqueLiftRight.velocity(velocityUnits::pct) > 0) {}
    //torqueLiftLeft.setRotation(0.0, rotationUnits::rev);
    //torqueLiftRight.setRotation(0.0, rotationUnits::rev);
}

void autonomous( void ) {
    if (START_POS == 0) // 0 for the closer tile, 1 for the farther
    {
        // Hit flag going forward 1.3s, then stop base
        moveBaseByRevs(-4.2, 100);
        // Going back
        
        vex::task::sleep(2000);
        moveBaseByRevs(2.1, 100); 
        
        vex::task::sleep(1000);
        tankMoveLeftMotorsByRevs(COLOR*1.6, 100);
        
        vex::task::sleep(200);
        
        tankMoveRightMotorsByRevs(-COLOR*0.7, 100);
        
        capFlipperToggleFwd();
        
        vex::task::sleep(500);
        moveBaseByRevs(4.2, 100);
        vex::task::sleep(2300);
        
        tankMoveLeftMotorsByRevs(COLOR*1.0, 100);
        tankMoveRightMotorsByRevs(-COLOR*1.0, 100);
        vex::task::sleep(1000);
        
        moveBaseByRevs(2.3, 100);
        vex::task::sleep(2500);
        
        moveBaseByRevs(-1.8, 100);  
        vex::task::sleep(1000);
        
        // Align with the platform
        tankMoveRightMotorsByRevs(-COLOR*1.0, 100);
        tankMoveLeftMotorsByRevs(COLOR*1.0, 100);
        vex::task::sleep(1000);
        
        moveBaseByRevs(0.45, 100);
        vex::task::sleep(600);
        
        tankMoveRightMotorsByRevs(COLOR*0.9, 100);
        tankMoveLeftMotorsByRevs(-COLOR*0.9, 100);
        vex::task::sleep(1000);
        capFlipperToggleFwd();
        vex::task::sleep(500);
        
        capFlipper.spin(directionType::rev, 100.0, velocityUnits::pct);
        
        baseMotorLeftFront.spin(directionType::rev, 100, velocityUnits::pct);
        baseMotorLeftBack.spin(directionType::rev, 100, velocityUnits::pct);
        
        baseMotorRightBack.spin(directionType::fwd, 100, velocityUnits::pct);
        baseMotorRightFront.spin(directionType::fwd, 100, velocityUnits::pct);
        vex::task::sleep(3000);
        baseMotorLeftFront.stop();
        baseMotorRightFront.stop();
        baseMotorLeftBack.stop();
        baseMotorRightBack.stop();
        capFlipper.stop();
    }
    else
    {
        // Put it normally
        capFlipperToggleFwd();
        moveBaseByRevs(-2.1, 100);
        vex::task::sleep(1000);
        
        tankMoveRightMotorsByRevs(COLOR*1.0, 100);
        tankMoveLeftMotorsByRevs(-COLOR*1.0, 100);
        vex::task::sleep(1000);
        
        moveBaseByRevs(4.2, 100);
        vex::task::sleep(2000);

        tankMoveRightMotorsByRevs(-COLOR*1.0, 100);
        tankMoveLeftMotorsByRevs(COLOR*1.0, 100);
        vex::task::sleep(1000);
        
        capFlipperToggleFwd();
        moveBaseByRevs(0.8, 100);
        vex::task::sleep(1000);
        
        moveBaseByRevs(-0.8, 100);
        vex::task::sleep(1000);
        
        tankMoveRightMotorsByRevs(-COLOR*1.0, 100);
        tankMoveLeftMotorsByRevs(COLOR*1.0, 100);
        vex::task::sleep(1000);
        
        moveBaseByRevs(0.4, 100);
        vex::task::sleep(1000);
        
        tankMoveRightMotorsByRevs(-COLOR*1.0, 100);
        tankMoveLeftMotorsByRevs(COLOR*1.0, 100);
        vex::task::sleep(1000);
        
        capFlipper.spin(directionType::rev, 100.0, velocityUnits::pct);
        vex::task::sleep(500);
        moveBaseByRevs(-4, 100);
        vex::task::sleep(3000);
        capFlipper.stop();
    }
}

void usercontrol( void ) {
    setCapFlipperControls();
    setClawControls();
    driveControl();
    ballControl();
    //debug();
}

int main() {
    pre_auton();

    //Set up callbacks for autonomous and driver control periods.
    Competition.autonomous( autonomous );
    Competition.drivercontrol( usercontrol );

    //Prevent main from exiting with an infinite loop.                        
    while(1) {
      vex::task::sleep(100);//Sleep the task for a short amount of time to prevent wasted resources.
    }   

    return 0;
}

void debug(){
    firstController.ButtonLeft.pressed([]{
        // Various debugging functions, loaded by left + smth
        firstController.ButtonRight.pressed([]{
            //void(*autonomousPtr)() = &autonomous;
            //autonomousPtr; // This interrupts something?
        });
    });
}

// -------------------------- Cap Flipper functions ------------------------ //

void setCapFlipperControls() {
    void (*capFlipperToggleFwdPtr)() = &capFlipperToggleFwd;
    void (*capFlipperToggleRevPtr)() = &capFlipperToggleRev;
    firstController.ButtonR1.pressed(capFlipperToggleFwdPtr);
    firstController.ButtonR2.pressed(capFlipperToggleRevPtr);
}

void capFlipperToggleFwd() {
    if (capFlipper.velocity(velocityUnits::pct) != 0) {
        capFlipper.stop();
    } else {
        capFlipper.spin(directionType::fwd, 80.0, velocityUnits::pct);
    }
}

void capFlipperToggleRev() {
    if (capFlipper.velocity(velocityUnits::pct) != 0) {
        capFlipper.stop();
    } else {
        capFlipper.spin(directionType::rev, 100.0, velocityUnits::pct);
    }
}

// -------------------------- Claw functions ------------------------ //
void setClawControls() {
   void (*clawUpPtr)() = &clawUp; 
   void (*clawDownPtr)() = &clawDown; 
   void (*clawUpReleasedPtr)() = &clawStop; 
   void (*clawDownReleasedPtr)() = &clawStop; 
   void (*liftOneLevelUpPtr)() = &liftOneLevelUp; 
   void (*liftOneLevelDownPtr)() = &liftOneLevelDown; 
   void (*stopLiftPtr)() = &stopLift; 
   firstController.ButtonUp.pressed(clawUpPtr);
   firstController.ButtonDown.pressed(clawDownPtr);
   firstController.ButtonUp.released(clawUpReleasedPtr);
   firstController.ButtonDown.released(clawDownReleasedPtr);
   firstController.ButtonL1.pressed(liftOneLevelUpPtr);
   firstController.ButtonL2.pressed(liftOneLevelDownPtr);
   firstController.ButtonL1.released(stopLiftPtr);
   firstController.ButtonL2.released(stopLiftPtr);
}

void clawStop() {
    clawMotor.stop(brakeType::hold);
}

void clawDown() {
    clawMotor.spin(directionType::rev, 100.0, velocityUnits::pct);
    while (firstController.ButtonDown.pressing()) {
        if (clawMotor.rotation(rotationUnits::rev) < -3.0) {
            clawMotor.spin(directionType::fwd, 0, velocityUnits::pct);
        }
    }
}

void clawUp() {
    clawMotor.spin(directionType::fwd, 100.0, velocityUnits::pct);
}

// ------------------------ Lift functions ------------------------ //
void liftOneLevelUp() {
    while (firstController.ButtonL1.pressing()){
        torqueLiftRight.spin(directionType::rev, 100, velocityUnits::pct);
        torqueLiftLeft.spin(directionType::fwd, 100, velocityUnits::pct);
        if (torqueLiftLeft.velocity(velocityUnits::pct) == 0) {
            return;
        }
    }

    stopLift();
}

void liftOneLevelDown() {
    while (firstController.ButtonL2.pressing()){
        torqueLiftRight.spin(directionType::fwd, 75, velocityUnits::pct);
        torqueLiftLeft.spin(directionType::rev, 75, velocityUnits::pct);
        if (torqueLiftLeft.velocity(velocityUnits::pct) == 0) {
            return;
        }
    }

    stopLift();
}

void stopLift() {
    torqueLiftRight.spin(directionType::fwd, 0, velocityUnits::pct);
    torqueLiftLeft.spin(directionType::rev, 0, velocityUnits::pct);
}

// ------------------ Drive functions --------------------- //
void driveControl() {
   void (*tankMoveLeftMotorsPtr)() = &tankMoveLeftMotors; 
   void (*tankMoveRightMotorsPtr)() = &tankMoveRightMotors; 
   firstController.Axis3.changed(tankMoveLeftMotorsPtr);
   firstController.Axis2.changed(tankMoveRightMotorsPtr);
}

void tankMoveLeftMotors() {
   double speed = -firstController.Axis3.position(percentUnits::pct);
   baseMotorLeftFront.spin(directionType::rev, speed, velocityUnits::pct);
   baseMotorLeftBack.spin(directionType::rev, speed, velocityUnits::pct);
}

void tankMoveRightMotors() {
   double speed = -firstController.Axis2.position(percentUnits::pct);
   baseMotorRightFront.spin(directionType::fwd, speed, velocityUnits::pct);
   baseMotorRightBack.spin(directionType::fwd, speed, velocityUnits::pct);
}

void moveBaseByRevs(double revs, double speed){
    baseMotorLeftFront.setStopping(brakeType::coast);
    baseMotorLeftBack.setStopping(brakeType::coast);
    baseMotorRightFront.setStopping(brakeType::coast);
    baseMotorRightFront.setStopping(brakeType::coast);
   baseMotorLeftFront.rotateFor(revs, rotationUnits::rev, speed, velocityUnits::pct, false);
   baseMotorLeftBack.rotateFor(revs, rotationUnits::rev, speed, velocityUnits::pct, false);
   baseMotorRightFront.rotateFor(-revs, rotationUnits::rev, speed, velocityUnits::pct, false);
   baseMotorRightBack.rotateFor(-revs, rotationUnits::rev, speed, velocityUnits::pct, false);
}

void tankMoveLeftMotorsByRevs(double revs, double speed) {
   baseMotorLeftFront.rotateFor(revs, rotationUnits::rev, speed, velocityUnits::pct, false);
   baseMotorLeftBack.rotateFor(revs, rotationUnits::rev, speed, velocityUnits::pct, false);
}

void tankMoveRightMotorsByRevs(double revs, double speed) {
   baseMotorRightFront.rotateFor(-revs, rotationUnits::rev, speed, velocityUnits::pct, false);
   baseMotorRightBack.rotateFor(-revs, rotationUnits::rev, speed, velocityUnits::pct, false);
}

// ------ Ball loading and shooting functions -------- //
void ballControl() {
   void (*loadBallPtr)() = &loadBall; 
   void (*unloadBallPtr)() = &unloadBall; 
   void (*ballLoaderStopPtr)() = &ballLoaderStop; 
   void (*shootBallStopPtr)() = &ballShooterStop; 
   void (*shootBallPtr)() = &shootBall; 
   firstController.ButtonX.pressed(shootBallPtr);
   firstController.ButtonX.released(shootBallStopPtr);
   firstController.ButtonR1.pressed(loadBallPtr);
   firstController.ButtonR2.pressed(unloadBallPtr);
   firstController.ButtonR1.released(ballLoaderStopPtr);
   firstController.ButtonR2.released(ballLoaderStopPtr);
}

void loadBall() {
        ballLoader.spin(directionType::rev, 100, velocityUnits::pct);
}

void unloadBall() {
        ballLoader.spin(directionType::fwd, 100, velocityUnits::pct);
}

void shootBall() {
        ballShooter.spin(directionType::rev, 100, velocityUnits::pct);
}

void ballShooterStop() {
        ballShooter.spin(directionType::rev, 0, velocityUnits::pct);
}

void ballLoaderStop() {
        ballLoader.spin(directionType::rev, 0, velocityUnits::pct);
} s