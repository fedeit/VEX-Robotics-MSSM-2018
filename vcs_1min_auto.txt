using namespace vex;

//Creates a competition object that allows access to Competition methods.
vex::competition    Competition;

// Constants
const int COLOR = -1; // -1 for red, 1 for blue

// Function declarations
void tankMoveRightMotors();
void tankMoveLeftMotors();
void tankMoveRightMotorsByRevs(double revs, double speed);
void tankMoveLeftMotorsByRevs(double revs, double speed);
void driveControl();
void ballControl();
void loadBall();
void unloadBall();
void ballShooterStop();
void shootBall();
void ballLoaderStop();
void moveBaseByRevs(double revs, double speed);
void setCapFlipperControls();
void capFlipperToggleFwd();
void capFlipperToggleRev();
void debug();
void moveByTiles(double tiles);
double fabs(double n);

// Motors object declaration
controller firstController = controller(controllerType::primary);
motor baseMotorLeftFront = motor(1, gearSetting::ratio18_1, false);
motor baseMotorRightFront = motor(19, gearSetting::ratio18_1, false);
motor baseMotorLeftBack = motor(8, gearSetting::ratio18_1, false);
motor baseMotorRightBack = motor(12, gearSetting::ratio18_1, false);
motor ballLoader = motor(18, gearSetting::ratio18_1, false);
motor ballShooter = motor(11, gearSetting::ratio18_1, false);
motor capFlipper = motor(9, gearSetting::ratio18_1, false);

double fabs(double n) { 
    if (n == 0)
        return 0;
    return n > 0 ? n : -n;
}

void pre_auton( void ) {
    ballShooter.setStopping(brakeType::coast);
}

void autonomous( void ) {
    ballLoader.spin(directionType::fwd, 100.0, velocityUnits::pct);
    
    shootBall();
    
    moveByTiles(1);
    
    shootBall();
    
    moveByTiles(1);

    moveByTiles(-2.2);
    
    // Turning 45 degrees, later make a separate function
    tankMoveLeftMotorsByRevs(-COLOR*1.1, 100);
    vex::task::sleep(2000);
    
    capFlipperToggleFwd();
    
    moveByTiles(1.5);
    
    // SAFE ONE - 9 pts
    moveByTiles(-1.35);
    
    tankMoveLeftMotorsByRevs(COLOR*1.1, 100);
    vex::task::sleep(2000);
    
    moveByTiles(-1.7);
    
    capFlipper.stop();
    
    tankMoveLeftMotorsByRevs(-COLOR*2.0, 100);
    vex::task::sleep(3000);

    capFlipperToggleRev();

    moveByTiles(3);
    
    capFlipper.stop();
    
    /* ISSUE SECOND CAP MAKES IT
        -- GO THROUGH THE PLATFORMS
        -- OR DONT HIT THE 2ND FLAG
    tankMoveRightMotorsByRevs(COLOR*1.00, 100);
    vex::task::sleep(2000);
    
    moveByTiles(4.18);

    tankMoveRightMotorsByRevs(-COLOR*2.40, 100);
    vex::task::sleep(4000);

    capFlipper.stop();
    
    moveByTiles(1.5);
    
    moveByTiles(-4.15);
    
    tankMoveRightMotorsByRevs(-COLOR*2.0, 100);
    vex::task::sleep(3000);

    capFlipperToggleRev();

    moveByTiles(2.7);
    
    capFlipper.stop();*/
}

void usercontrol( void ) {
    debug();
}

int main() {
    pre_auton();

    //Set up callbacks for autonomous and driver control periods.
    Competition.autonomous( autonomous );
    Competition.drivercontrol( usercontrol );

    //Prevent main from exiting with an infinite loop.                        
    while(1) {
      vex::task::sleep(100);//Sleep the task for a short amount of time to prevent wasted resources.
    }   

    return 0;
}

void debug(){
    firstController.ButtonLeft.pressed([]{
        autonomous();
    });
}

// -------------------------- Cap Flipper functions ------------------------ //
void capFlipperToggleFwd() {
    if (capFlipper.velocity(velocityUnits::pct) != 0) {
        capFlipper.stop();
    } else {
        capFlipper.spin(directionType::fwd, 50.0, velocityUnits::pct);
    }
}

void capFlipperToggleRev() {
    if (capFlipper.velocity(velocityUnits::pct) != 0) {
        capFlipper.stop();
    } else {
        capFlipper.spin(directionType::rev, 100.0, velocityUnits::pct);
    }
}

// ------------------ Drive functions --------------------- //
void tankMoveLeftMotors() {
    double speed = -firstController.Axis3.position(percentUnits::pct);
    baseMotorLeftFront.spin(directionType::rev, speed, velocityUnits::pct);
    baseMotorLeftBack.spin(directionType::rev, speed, velocityUnits::pct);
}

void tankMoveRightMotors() {
    double speed = -firstController.Axis2.position(percentUnits::pct);
    baseMotorRightFront.spin(directionType::fwd, speed, velocityUnits::pct);
    baseMotorRightBack.spin(directionType::fwd, speed, velocityUnits::pct);
}

void moveBaseByRevs(double revs, double speed){
    baseMotorLeftFront.setStopping(brakeType::coast);
    baseMotorLeftBack.setStopping(brakeType::coast);
    baseMotorRightFront.setStopping(brakeType::coast);
    baseMotorRightFront.setStopping(brakeType::coast);
    baseMotorLeftFront.rotateFor(revs, rotationUnits::rev, speed, velocityUnits::pct, false);
    baseMotorLeftBack.rotateFor(revs, rotationUnits::rev, speed, velocityUnits::pct, false);
    baseMotorRightFront.rotateFor(-revs, rotationUnits::rev, speed, velocityUnits::pct, false);
    baseMotorRightBack.rotateFor(-revs, rotationUnits::rev, speed, velocityUnits::pct, false);
}

void tankMoveLeftMotorsByRevs(double revs, double speed) {
    baseMotorLeftFront.rotateFor(revs, rotationUnits::rev, speed, velocityUnits::pct, false);
    baseMotorLeftBack.rotateFor(revs, rotationUnits::rev, speed, velocityUnits::pct, false);
}

void tankMoveRightMotorsByRevs(double revs, double speed) {
    baseMotorRightFront.rotateFor(-revs, rotationUnits::rev, speed, velocityUnits::pct, false);
    baseMotorRightBack.rotateFor(-revs, rotationUnits::rev, speed, velocityUnits::pct, false);
}

void moveByTiles(double tiles) {
    moveBaseByRevs(1.9*tiles, 100);
    vex::task::sleep(900*fabs(tiles));
}

/*void turnByDegrees(double degrees) {
    
}*/
// ------ Ball loading and shooting functions -------- //
void loadBall() {
    ballLoader.spin(directionType::rev, 100, velocityUnits::pct);
}

void unloadBall() {
    ballLoader.spin(directionType::fwd, 100, velocityUnits::pct);
}

void shootBall() {
    ballShooter.spin(directionType::rev, 100.0, velocityUnits::pct);
    vex::task::sleep(2000);
    ballShooter.stop();
}

void ballShooterStop() {
        ballShooter.spin(directionType::rev, 0, velocityUnits::pct);
}

void ballLoaderStop() {
        ballLoader.spin(directionType::rev, 0, velocityUnits::pct);
}
