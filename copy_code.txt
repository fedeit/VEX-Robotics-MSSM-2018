using namespace vex;

//Creates a competition object that allows access to Competition methods.
vex::competition    Competition;

// Constants
const short COLOR = 1; // -1 for red, 1 for blue
const short START_POS = 0; // 0 for closer one, 1 for the farther one

// Function declarations
void liftOneLevelUp();
void liftOneLevelDown();
void setClawControls();
void tankMoveRightMotors();
void tankMoveLeftMotors();
void tankMoveRightMotorsByRevs(double revs, double speed);
void tankMoveLeftMotorsByRevs(double revs, double speed);
void driveControl();
void stopLift();
void ballControl();
void loadBall();
void unloadBall();
void ballShooterStop();
void shootBall();
void ballLoaderStop();
void clawStop();
void debug(); // Debug function?
void moveBaseByRevs(double revs, double speed);
void setCapFlipperControls();
void capFlipperToggle();
void clawDown();
void clawUp();
void setLiftControls();

// Motors object declaration
controller firstController = controller(controllerType::primary);
motor clawMotor = motor(7, gearSetting::ratio18_1, false);
motor baseMotorLeftFront = motor(10, gearSetting::ratio18_1, false);
motor baseMotorRightFront = motor(6, gearSetting::ratio18_1, false);
motor baseMotorLeftBack = motor(9, gearSetting::ratio18_1, false);
motor baseMotorRightBack = motor(8, gearSetting::ratio18_1, false);
motor torqueLiftLeft = motor(3, gearSetting::ratio36_1, false);
motor torqueLiftRight = motor(1, gearSetting::ratio36_1, false);
motor ballLoader = motor(4, gearSetting::ratio18_1, false);
motor ballShooter = motor(2, gearSetting::ratio18_1, false);
motor capFlipper = motor(5, gearSetting::ratio18_1, false);


/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */ 
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton( void ) {
    //---------------------------------------------------------------------------
    //                                 SET STOPPINGS                                
    //  Set claw and lift motors to Hold stopping                                
    //---------------------------------------------------------------------------

    torqueLiftLeft.setStopping(brakeType::hold);
    torqueLiftRight.setStopping(brakeType::hold);
    clawMotor.setStopping(brakeType::hold);
    ballShooter.setStopping(brakeType::coast);
    //---------------------------------------------------------------------------
    //                          CALIBRATE LIFT AND CLAW                               
    //  Bring motors lift to lowest possible pos, check for v=0,                 
    //  and then set absolute value of rotation to 0                                 
    //---------------------------------------------------------------------------
    //torqueLiftLeft.spin(directionType::rev);
    //torqueLiftRight.spin(directionType::rev);
    //while (torqueLiftLeft.velocity(velocityUnits::pct) > 0 || torqueLiftRight.velocity(velocityUnits::pct) > 0) {}
    //torqueLiftLeft.setRotation(0.0, rotationUnits::rev);
    //torqueLiftRight.setRotation(0.0, rotationUnits::rev);
}

void autonomous( void ) {
    if (START_POS == 0) // 0 for the closer tile, 1 for the farther
    {
        // Hit flag going forward 1.3s, then stop base
        moveBaseByRevs(4.00, 100);
        // Going back
        moveBaseByRevs(-1.00, 100); 
        // Turning the back so it would hit the lower flag in the middle
        if (COLOR == -1) // Starting with red color
            tankMoveLeftMotorsByRevs(-2.00, 100);
        else
            tankMoveRightMotorsByRevs(-2.00, 100);
        
        // Add the flipping part? 
        
        // Hitting the flag in the middle
        moveBaseByRevs(-1.5, 100);
        
        if (COLOR == -1)
            tankMoveRightMotorsByRevs(-0.5, 100);
        else
            tankMoveLeftMotorsByRevs(-0.5, 100);
        
        moveBaseByRevs(-1.00, 100);
        // Align with the platform
        moveBaseByRevs(0.5, 100);
        tankMoveRightMotorsByRevs(-COLOR*0.5, 100);
        tankMoveLeftMotorsByRevs(COLOR*0.5, 100);
        moveBaseByRevs(2.5, 100); // Jumping on the platform from the front side of the robot
        tankMoveRightMotorsByRevs(-COLOR*0.5, 100);
        tankMoveLeftMotorsByRevs(COLOR*0.5, 100);
        moveBaseByRevs(0.3, 100); // Jumping on the second platform
    }
    else
    {
        // Second autonomous for the outer starting tile
        // Flip some stuff and get on the platform
    }
    
}

void usercontrol( void ) {
    setCapFlipperControls();
    setClawControls();
    driveControl();
    ballControl();
    setLiftControls();
    //debug();
}

int main() {
    pre_auton();

    //Set up callbacks for autonomous and driver control periods.
    Competition.autonomous( autonomous );
    Competition.drivercontrol( usercontrol );

    //Prevent main from exiting with an infinite loop.                        
    while(1) {
      vex::task::sleep(100);//Sleep the task for a short amount of time to prevent wasted resources.
    }   
    
    return 0;
}

void debug(){
    firstController.ButtonLeft.pressed([]{
        // Various debugging functions, loaded by left + smth
        firstController.ButtonRight.pressed([]{
            void(*autonomousPtr)() = &autonomous;
            autonomousPtr; // This interrupts something?
        });
    });
}

// -------------------------- Cap Flipper functions ------------------------ //

void setCapFlipperControls() {
    void (*capFlipperTogglePtr)() = &capFlipperToggle;
    firstController.ButtonY.pressed(capFlipperTogglePtr);
}

void capFlipperToggle() {
    if (capFlipper.velocity(velocityUnits::pct) != 0) {
        capFlipper.stop();
    } else {
        capFlipper.spin(directionType::rev, 80.0, velocityUnits::pct);
    }
}

// -------------------------- Claw functions ------------------------ //
void setClawControls() {
   void (*clawUpPtr)() = &clawUp; 
   void (*clawDownPtr)() = &clawDown; 
   void (*clawUpReleasedPtr)() = &clawStop; 
   void (*clawDownReleasedPtr)() = &clawStop; 
   firstController.ButtonUp.pressed(clawUpPtr);
   firstController.ButtonDown.pressed(clawDownPtr);
   firstController.ButtonUp.released(clawUpReleasedPtr);
   firstController.ButtonDown.released(clawDownReleasedPtr);
}

void clawStop() {
    clawMotor.stop(brakeType::hold);
}

void clawDown() {
    clawMotor.spin(directionType::rev, 100.0, velocityUnits::pct);
    while (firstController.ButtonDown.pressing()) {
        if (clawMotor.rotation(rotationUnits::rev) < -3.0) {
            clawMotor.spin(directionType::fwd, 0, velocityUnits::pct);
        }
    }
}

void clawUp() {
    clawMotor.spin(directionType::fwd, 100.0, velocityUnits::pct);
}

// ------------------------ Lift functions ------------------------ //
void setLiftControls(){
   void (*liftOneLevelUpPtr)() = &liftOneLevelUp; 
   void (*liftOneLevelDownPtr)() = &liftOneLevelDown; 
   void (*stopLiftPtr)() = &stopLift; 
   firstController.ButtonL1.pressed(liftOneLevelUpPtr);
   firstController.ButtonL2.pressed(liftOneLevelDownPtr);
   firstController.ButtonL1.released(stopLiftPtr);
   firstController.ButtonL2.released(stopLiftPtr);
}
void liftOneLevelUp() {
    while (firstController.ButtonL1.pressing()){
        torqueLiftRight.spin(directionType::rev, 100, velocityUnits::pct);
        torqueLiftLeft.spin(directionType::fwd, 100, velocityUnits::pct);
        if (torqueLiftLeft.velocity(velocityUnits::pct) == 0) {
            return;
        }
    }
    
    stopLift();
}

void liftOneLevelDown() {
    while (firstController.ButtonL2.pressing()){
        torqueLiftRight.spin(directionType::fwd, 75, velocityUnits::pct);
        torqueLiftLeft.spin(directionType::rev, 75, velocityUnits::pct);
        if (torqueLiftLeft.velocity(velocityUnits::pct) == 0) {
            return;
        }
    }
    
    stopLift();
}

void stopLift() {
    torqueLiftRight.spin(directionType::fwd, 0, velocityUnits::pct);
    torqueLiftLeft.spin(directionType::rev, 0, velocityUnits::pct);
}

// ------------------ Drive functions --------------------- //
void driveControl() {
   void (*tankMoveLeftMotorsPtr)() = &tankMoveLeftMotors; 
   void (*tankMoveRightMotorsPtr)() = &tankMoveRightMotors; 
   firstController.Axis3.changed(tankMoveLeftMotorsPtr);
   firstController.Axis2.changed(tankMoveRightMotorsPtr);
}

void tankMoveLeftMotors() {
   double speed = -firstController.Axis3.position(percentUnits::pct);
   baseMotorLeftFront.spin(directionType::rev, speed, velocityUnits::pct);
   baseMotorLeftBack.spin(directionType::rev, speed, velocityUnits::pct);
}

void tankMoveRightMotors() {
   double speed = -firstController.Axis2.position(percentUnits::pct);
   baseMotorRightFront.spin(directionType::fwd, speed, velocityUnits::pct);
   baseMotorRightBack.spin(directionType::fwd, speed, velocityUnits::pct);
}

void moveBaseByRevs(double revs, double speed){
    tankMoveRightMotorsByRevs(revs, speed);
    tankMoveLeftMotorsByRevs(revs, speed);
}

void tankMoveLeftMotorsByRevs(double revs, double speed) {
   baseMotorLeftFront.rotateTo(revs, rotationUnits::rev, speed, velocityUnits::pct, false);
   baseMotorLeftBack.rotateTo(revs, rotationUnits::rev, speed, velocityUnits::pct, false);
}

void tankMoveRightMotorsByRevs(double revs, double speed) {
   baseMotorRightFront.rotateTo(-revs, rotationUnits::rev, speed, velocityUnits::pct, false);
   baseMotorRightBack.rotateTo(-revs, rotationUnits::rev, speed, velocityUnits::pct, false);
}

// ------ Ball loading and shooting functions -------- //
void ballControl() {
   void (*loadBallPtr)() = &loadBall; 
   void (*unloadBallPtr)() = &unloadBall; 
   void (*ballLoaderStopPtr)() = &ballLoaderStop; 
   void (*shootBallStopPtr)() = &ballShooterStop; 
   void (*shootBallPtr)() = &shootBall; 
   firstController.ButtonX.pressed(shootBallPtr);
   firstController.ButtonX.released(shootBallStopPtr);
   firstController.ButtonR1.pressed(loadBallPtr);
   firstController.ButtonR2.pressed(unloadBallPtr);
   firstController.ButtonR1.released(ballLoaderStopPtr);
   firstController.ButtonR2.released(ballLoaderStopPtr);
}

void loadBall() {
        ballLoader.spin(directionType::rev, 100, velocityUnits::pct);
}

void unloadBall() {
        ballLoader.spin(directionType::fwd, 100, velocityUnits::pct);
}

// Flywheel
void shootBall() {
        ballShooter.spin(directionType::rev, 100, velocityUnits::pct);
}

void ballShooterStop() {
        ballShooter.spin(directionType::rev, 0, velocityUnits::pct);
}

void ballLoaderStop() {
        ballLoader.spin(directionType::rev, 0, velocityUnits::pct);
}